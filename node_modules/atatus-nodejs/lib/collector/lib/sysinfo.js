'use strict';

const os = require('os');
const exec = require('child_process').exec;
const execSync = require('child_process').execSync;
const fs = require('fs');

let _platform = process.platform;

const _linux = (_platform === 'linux');
const _darwin = (_platform === 'darwin');
const _windows = (_platform === 'win32');
const _freebsd = (_platform === 'freebsd');
const _openbsd = (_platform === 'openbsd');
const _netbsd = (_platform === 'netbsd');
const _sunos = (_platform === 'sunos');

const NOT_SUPPORTED = 'not supported';

// --------------------------
// Get current time and OS uptime

function time() {
  let t = new Date().toString().split(' ');

  return {
    current: Date.now(),
    uptime: os.uptime(),
    timezone: (t.length >= 7) ? t[5] : '',
    timezoneName: (t.length >= 7) ? t.slice(6).join(' ').replace(/\(/g, '').replace(/\)/g, '') : ''
  };
}

exports.time = time;

function getValue(lines, property, separator, trimmed) {
  separator = separator || ':';
  property = property.toLowerCase();
  trimmed = trimmed || false;
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i].toLowerCase().replace(/\t/g, '');
    if (trimmed) {
      line = line.trim();
    }
    if (line.startsWith(property)) {
      const parts = lines[i].split(separator);
      if (parts.length >= 2) {
        parts.shift();
        return parts.join(separator).trim();
      } else {
        return '';
      }
    }
  }
  return '';
}

// --------------------------
// OS Information

function osInfo(callback) {

  return new Promise((resolve) => {
    process.nextTick(() => {
      let result = {
        os: (_platform === 'Windows_NT' ? 'Windows' : _platform),
        platform: 'unknown',
        release: 'unknown',
        codename: '',
        kernel: os.release(),
        arch: os.arch(),
        hostname: os.hostname(),
        productId: '',
        bootId: '',
        hostId: '',
        build: '',
        servicepack: '',
        ram: os.totalmem(),
        cpu: []
      };

      let cpus = os.cpus();
      for (let i = 0; i < cpus.length; i++) {
        result.cpu.push({
            cores: 1,
            mhz: cpus[i].speed,
            model: cpus[i].model
        });
      }

      if (_linux) {

        exec('cat /etc/*-release; cat /usr/lib/os-release; cat /etc/openwrt_release', function (error, stdout) {
          //if (!error) {
          /**
           * @namespace
           * @property {string}  DISTRIB_ID
           * @property {string}  NAME
           * @property {string}  DISTRIB_RELEASE
           * @property {string}  VERSION_ID
           * @property {string}  DISTRIB_CODENAME
           */
          let release = {};
          let lines = stdout.toString().split('\n');
          lines.forEach(function (line) {
            if (line.indexOf('=') !== -1) {
              release[line.split('=')[0].trim().toUpperCase()] = line.split('=')[1].trim();
            }
          });
          let releaseVersion = (release.VERSION || '').replace(/"/g, '');
          let codename = (release.DISTRIB_CODENAME || release.VERSION_CODENAME || '').replace(/"/g, '');
          if (releaseVersion.indexOf('(') >= 0) {
            codename = releaseVersion.split('(')[1].replace(/[()]/g, '').trim();
            releaseVersion = releaseVersion.split('(')[0].trim();
          }
          result.platform = (release.DISTRIB_ID || release.NAME || 'unknown').replace(/"/g, '');
          result.release = (releaseVersion || release.DISTRIB_RELEASE || release.VERSION_ID || 'unknown').replace(/"/g, '');
          result.codename = codename;
          result.build = (release.BUILD_ID || '').replace(/"/g, '').trim();
          uuid().then(data => {
            result.productId = data.uuid;
            return bootId();
          }).then(data => {
            result.bootId = data.bootId
            result.hostId = result.bootId || result.productId || result.hostname
            if (callback) {
              callback(result);
            }
            resolve(result);
          });
          //}
        });

      } else if (_freebsd || _openbsd || _netbsd) {

        exec('sysctl kern.ostype kern.osrelease kern.osrevision kern.hostuuid', function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');
            result.platform = getValue(lines, 'kern.ostype');
            result.release = getValue(lines, 'kern.osrelease').split('-')[0];
            result.productId = getValue(lines, 'kern.uuid');
            result.bootId = result.productId
            result.hostId = result.productId
            result.codename = '';
          }
          if (callback) {
            callback(result);
          }
          resolve(result);
        });

      } else if (_darwin) {
        exec('sw_vers; sysctl kern.ostype kern.osrelease kern.osrevision kern.uuid', function (error, stdout) {
          let lines = stdout.toString().split('\n');
          result.productId = (getValue(lines, 'kern.uuid') || '').toLowerCase();
          result.platform = getValue(lines, 'ProductName');
          result.release = getValue(lines, 'ProductVersion');
          result.build = getValue(lines, 'BuildVersion');
          result.codename = 'macOS';
          result.codename = (result.release.indexOf('10.4') > -1 ? 'Mac OS X Tiger' : result.codename);
          result.codename = (result.release.indexOf('10.4') > -1 ? 'Mac OS X Tiger' : result.codename);
          result.codename = (result.release.indexOf('10.4') > -1 ? 'Mac OS X Tiger' : result.codename);
          result.codename = (result.release.indexOf('10.5') > -1 ? 'Mac OS X Leopard' : result.codename);
          result.codename = (result.release.indexOf('10.6') > -1 ? 'Mac OS X Snow Leopard' : result.codename);
          result.codename = (result.release.indexOf('10.7') > -1 ? 'Mac OS X Lion' : result.codename);
          result.codename = (result.release.indexOf('10.8') > -1 ? 'OS X Mountain Lion' : result.codename);
          result.codename = (result.release.indexOf('10.9') > -1 ? 'OS X Mavericks' : result.codename);
          result.codename = (result.release.indexOf('10.10') > -1 ? 'OS X Yosemite' : result.codename);
          result.codename = (result.release.indexOf('10.11') > -1 ? 'OS X El Capitan' : result.codename);
          result.codename = (result.release.indexOf('10.12') > -1 ? 'macOS Sierra' : result.codename);
          result.codename = (result.release.indexOf('10.13') > -1 ? 'macOS High Sierra' : result.codename);
          result.codename = (result.release.indexOf('10.14') > -1 ? 'macOS Mojave' : result.codename);
          result.bootId = result.productId
          result.hostId = result.productId

          if (callback) {
            callback(result);
          }
          resolve(result);
        });

      } else {
        if (callback) {
          callback(result);
        }
        resolve(result);
      }
    });
  });
}

exports.osInfo = osInfo;

function uuid(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {

      let result = {
        uuid: ''
      };
      let parts;

      if (_darwin) {
        exec('ioreg -rd1 -c IOPlatformExpertDevice | grep IOPlatformUUID', function (error, stdout) {
          if (!error) {
            parts = stdout.toString().split('\n')[0].replace(/"/g, '').split('=');
            result.uuid = parts.length > 1 ? parts[1].trim().toLowerCase() : '';
          }
          if (callback) {
            callback(result);
          }
          resolve(result);
        });

      } else if (_linux) {
        // First get the product id
        // If the product id is not there, then get the machine.
        exec('cat /sys/class/dmi/id/product_uuid', function (error, stdout) {
          if (!error) {
            result.uuid = stdout.toString().split('\n')[0].trim().toLowerCase();
            if (callback) {
              callback(result);
            }
            resolve(result);
          } else {
            // Get the machine id
            exec('( cat /var/lib/dbus/machine-id /etc/machine-id 2> /dev/null || hostname ) | head -n 1 || :', function (error, stdout) {
              if (!error) {
                result.uuid = stdout.toString().split('\n')[0].trim().toLowerCase();
              }
              if (callback) {
                callback(result);
              }
              resolve(result);
            });
          }
        });

      } else if (_freebsd || _openbsd || _netbsd) {
        exec('kenv -q smbios.system.uuid', function (error, stdout) {
          if (!error) {
            result.uuid = stdout.toString().split('\n')[0].trim().toLowerCase();
          }
          if (callback) {
            callback(result);
          }
          resolve(result);
        });
      } else {
        if (callback) {
          callback(result);
        }
        resolve(result);
      }
    });
  });
}

exports.uuid = uuid;

function bootId(callback) {
  return new Promise((resolve) => {
    process.nextTick(() => {

      let result = {
        bootId: ''
      };
      let parts;

      if (_linux) {
        exec('cat /proc/sys/kernel/random/boot_id', function (error, stdout) {
          if (!error) {
            result.bootId = stdout.toString().split('\n')[0].trim().toLowerCase();
          }
          if (callback) {
            callback(result);
          }
          resolve(result);
        });
      } else {
        if (callback) {
          callback(result);
        }
        resolve(result);
      }
    });
  });
}

exports.bootId = bootId;

