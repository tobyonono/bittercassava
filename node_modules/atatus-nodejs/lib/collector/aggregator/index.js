'use strict'
const util = require('util')
const LimitedPriorityQueue = require('../lib/priorityqueue')
const Queue = require('../lib/queue')

const ERROR_EVENTS_LIMIT = 5
const ERROR_REQUESTS_LIMIT = 20
const TRACE_EVENTS_LIMIT = 5
const KIND_TRANSACTION = 'transaction'
const TYPE_NODEJS = 'Node.js'

const TIMEOUT_DURATION = 5 * 60 * 1000    // 5 minutes

module.exports = Aggregator

function Aggregator(agent) {
    this.agent = agent
    this.transactionSpans = {}
    this.transactions = {}
    this.errorMetrics = {}
    this.errorEvents = new Queue(ERROR_EVENTS_LIMIT)
    this.errorRequests = new Queue(ERROR_REQUESTS_LIMIT)
    this.traceEvents = new LimitedPriorityQueue(TRACE_EVENTS_LIMIT)
    this.metrics = []
}

function _getSpanType (spanType) {
    if (spanType === TYPE_NODEJS) {
        return {
            kind: TYPE_NODEJS,
            type: TYPE_NODEJS,
            knownKind: false
        }
    }
    let spanTypes = spanType.split('.')

    let availableKinds = {
      'db': 'Database',
      'cache': 'Database',
      'ext': 'Remote',
      'websocket': 'Remote',
      'template': 'Template'
    }

    let availableTypes = {
      'mysql': 'MySQL',
      'postgresql': 'Postgres',
      'mssql': 'MS SQL',
      'mongodb': 'MongoDB',
      'redis': 'Redis',
      'graphql': 'GraphQL',
      'elasticsearch': 'Elasticsearch',
      'cassandra': 'Cassandra',
      'http': 'External Requests',
      'http2': 'External Requests'
    }

    let kind = availableKinds[spanTypes[0]] || spanTypes[0]
    let type = availableTypes[spanTypes[1]] || spanTypes[1]

    if (spanTypes[0] === 'websocket') {
        type = 'WebSocket'
    } else if (spanTypes[0] === 'template') {
        type = 'Template'
    }

    return {
        kind: kind,
        type: type || kind,
        knownKind: !!availableKinds[spanTypes[0]]
    }
}

Aggregator.prototype.addTxn = function (item) {
    let txnName = item.name;
    if (!txnName) {
      return;
    }

    item.duration = item.duration || 0
    let txn = this.transactions[txnName]
    if (!txn) {
        txn = {
            name: txnName,
            background: (item.type === 'background'),
            // [count, total, min, max ]
            durations: [ 0, 0, item.duration, item.duration ],
            kind: KIND_TRANSACTION,
            type: this.agent._conf.frameworkName,
            spansObject: {}
        }
    }
    this.transactions[txnName] = txn

    // [count, total, min, max ]
    txn.durations[0]++
    txn.durations[1] += item.duration
    txn.durations[2] = Math.min(item.duration, txn.durations[2])
    txn.durations[3] = Math.max(item.duration, txn.durations[3])

    if (!this.transactionSpans[item.id]) {
        this.transactionSpans[item.id] = {
          spansArray: []
        }
    }

    if (this.transactionSpans[item.id].timeoutId) {
      clearTimeout(this.transactionSpans[item.id].timeoutId)
    }

    let totalSpanTime = 0
    this.transactionSpans[item.id].spansArray.forEach(function(span) {
        let spanName = span.name
        if (!spanName) {
            return;
        }

        span.duration = span.duration || 0

        let spanObj = txn.spansObject[spanName]
        if (!spanObj) {
            spanObj = {
                name: spanName,
                // durations: [count, total, min, max ]
                durations: [ 0, 0, span.duration, span.duration ]
            }
        }
        txn.spansObject[spanName] = spanObj

        let spanTypes = _getSpanType(span.type)
        spanObj.type = spanTypes.type
        spanObj.kind = spanTypes.kind

        // To avoid adding custom span duration in total span time.
        if (spanTypes.knownKind) {
            totalSpanTime += span.duration
        }

        // [count, total, min, max ]
        spanObj.durations[0]++
        spanObj.durations[1] += span.duration
        spanObj.durations[2] = Math.min(span.duration, spanObj.durations[2])
        spanObj.durations[3] = Math.max(span.duration, spanObj.durations[3])
    })

    // Calculate nodejs span
    if (totalSpanTime < item.duration) {
        let duration = item.duration - totalSpanTime
        let spanName = this.agent._conf.frameworkName || TYPE_NODEJS

        let spanObj = txn.spansObject[spanName]
        if (!spanObj) {
            spanObj = {
                name: spanName,
                // durations: [count, total, min, max ]
                durations: [ 0, 0, duration, duration ]
            }
        }
        txn.spansObject[spanName] = spanObj

        if (spanObj.durations[0] === 0) {
            spanObj.type = TYPE_NODEJS
            spanObj.kind = TYPE_NODEJS
        }

        // [count, total, min, max ]
        spanObj.durations[0]++
        spanObj.durations[1] += duration
        spanObj.durations[2] = Math.min(duration, spanObj.durations[2])
        spanObj.durations[3] = Math.max(duration, spanObj.durations[3])
    }

    if (item.duration >= this.agent._conf.traceThreshold) {
        item.spansArray = this.transactionSpans[item.id].spansArray

        if (totalSpanTime < item.duration) {
            item.spansArray.unshift({
                transaction_id: item.id,
                parent_id: item.id,
                trace_id: item.trace_id,
                name: this.agent._conf.frameworkName || TYPE_NODEJS,
                type: TYPE_NODEJS,
                duration: item.duration - totalSpanTime,
            })
        }

        this.traceEvents.add(item)
    }

    delete this.transactionSpans[item.id]
}

Aggregator.prototype.addSpan = function (item) {
    let spanName = item.name
    let transaction_id = item.transaction_id

    if (!spanName || (spanName === this.agent._conf.serverHost)) {
        return;
    }

    this.transactionSpans[transaction_id] =  this.transactionSpans[transaction_id] || { spansArray: null };
    let spansArray = this.transactionSpans[transaction_id].spansArray;

    if (spansArray) {
        spansArray.push(item)
    } else {
        this.transactionSpans[transaction_id].spansArray = [ item ]

        // Clear spans after certain duration
        let timeoutId = setTimeout( () => {
            if (this.transactionSpans[transaction_id]) {
                delete this.transactionSpans[transaction_id];
            }
        }, TIMEOUT_DURATION);

        this.transactionSpans[transaction_id].timeoutId = timeoutId
    }
}

Aggregator.prototype.addErrorEvents = function (item) {
    let exception = item.exception || item.log
    if (!exception) {
        return;
    }

    let error = {
        timestamp: new Date().getTime(),
        request: _getRequestHeader(item.context),
        customData: item.context && item.context.custom,
        tags: item.context && item.context.tags && Object.values(item.context.tags),
        user: item.context && item.context.user
    }

    error.exceptions = [{
        class: exception.type || 'Error',
        message: exception.message,
        stacktrace: []
    }]

    exception.stacktrace = exception.stacktrace || []
    exception.stacktrace.forEach(function(callSite) {
        // Ignore if file name is containing atatus nodejs, anonymous or no file name
        let fileName = callSite.filename
        if (!fileName || fileName.indexOf("/atatus-nodejs/") !== -1 || fileName === "<anonymous>") {
            return;
        }

        let frame = {
           f: fileName,
           p: callSite.abs_path,
           m: callSite.function || "none",
           ln: callSite.lineno,
           inp: !callSite.library_frame
        };
        error.exceptions[0].stacktrace.push(frame)
    });

    this.errorEvents.add(error)
}

Aggregator.prototype.addErrorMetrics = function (statusCode, item) {
    let txnName = item.name;
    if (!txnName || !statusCode) {
      return;
    }

    let errorMetric = this.errorMetrics[item.name]
    if (!errorMetric) {
        errorMetric = {
            name: txnName,
            kind: "transaction",
            type: this.agent._conf.frameworkName,
            statusCodes: {}
        }
    }
    let requestHeader = item.context &&
                   item.context.request &&
                   item.context.request.headers || {}

    this.errorMetrics[item.name] = errorMetric
    errorMetric.statusCodes[statusCode] = (errorMetric.statusCodes[statusCode] || 0) + 1;

    let errorRequests = {
        name: txnName,
        type: this.agent._conf.frameworkName,
        kind: KIND_TRANSACTION,
        request: _getRequestHeader(item.context),
        customData: item.context && item.context.custom,
        tags: item.context && item.context.tags && Object.values(item.context.tags),
        user: item.context && item.context.user
    }

    this.errorRequests.add(errorRequests)
}

Aggregator.prototype.addMetric = function (item) {

    if (!item || !item.samples) {
        return
    }

    let samples = item.samples
    let metric = {
        cpu: {
            total: (samples['system.cpu.total.norm.pct'] && samples['system.cpu.total.norm.pct'].value) || 0
        },
        memory: {
            total: (samples['system.memory.total'] && samples['system.memory.total'].value) || 0,
            actualFree: (samples['system.memory.actual.free'] && samples['system.memory.actual.free'].value) || 0
        },
        process: {
            cpu: {
                total: (samples['system.process.cpu.total.norm.pct'] && samples['system.process.cpu.total.norm.pct'].value) || 0,
                system: (samples['system.process.cpu.system.norm.pct'] && samples['system.process.cpu.system.norm.pct'].value) || 0,
                user: (samples['system.process.cpu.user.norm.pct'] && samples['system.process.cpu.user.norm.pct'].value) || 0
            },
            memory: {
                rssBytes: (samples['system.process.memory.rss.bytes'] && samples['system.process.memory.rss.bytes'].value) || 0
            }
        },
        nodejs: {
            handlesActive: (samples['nodejs.handles.active'] && samples['nodejs.handles.active'].value) || 0,
            requestsActive: (samples['nodejs.requests.active'] && samples['nodejs.requests.active'].value) || 0,
            eventLoopDelay: (samples['nodejs.eventloop.delay.avg.ms'] && samples['nodejs.eventloop.delay.avg.ms'].value) || 0,
            memoryHeapAllocated: (samples['nodejs.memory.heap.allocated.bytes'] && samples['nodejs.memory.heap.allocated.bytes'].value) || 0,
            memoryHeapUsed: (samples['nodejs.memory.heap.used.bytes'] && samples['nodejs.memory.heap.used.bytes'].value) || 0
        },
        timestamp: item.timestamp
    }

    this.metrics.push(metric)
}

function _getRequestHeader (context) {
    let request = context && context.request || {}
    let requestHeader = request && request.headers || {}
    let response = context && context.response || {}
    let ip = requestHeader['x-forwarded-for'] || requestHeader['X-Forwarded-For'] ||
            (request.socket && request.socket.remote_address) || ''

    ip = ip.split(',')[0] || ''

    return {
        accept: requestHeader.accept,
        'accept-encoding': requestHeader['accept-encoding'],
        'accept-language': requestHeader['accept-language'],
        ip: ip,
        referer: requestHeader.referer,
        host: requestHeader.host,
        port: 0,
        method: request.method,
        userAgent: requestHeader['user-agent'],
        path: request.url && request.url.raw || '',
        statusCode: response.status_code
    }
}

Aggregator.prototype.getAndResetTracesPayload = function getTracesPayload () {

    let traceEvents = this.traceEvents.toArray() || []
    this.resetTraces()

    let tracesPayload = []

    traceEvents.forEach((event) => {

        let txnName = event.name;
        if (!txnName) {
          return;
        }

        let trace = {
            name: txnName,
            id: event.id,
            type: this.agent._conf.frameworkName,
            kind: KIND_TRANSACTION,
            // start: 389882784298,
            duration: event.duration,
            entries: [],
            funcs: [],
            request: _getRequestHeader(event.context),
            customData: event.context && event.context.custom,
            tags: event.context && event.context.tags && Object.values(event.context.tags),
            user: event.context && event.context.user
        }

        event.spansArray.forEach((span, index) => {
            let spanTypes = _getSpanType(span.type)
            let traceEntry = {
                i: index,
                lv: 1, //span.level ||
                so: span.startOffset || 0,
                du: span.duration,
                ly: {
                    name: span.name,
                    type: spanTypes.type,
                    kind: spanTypes.kind
                },
            }

            if (span.context && span.context.db) {
                traceEntry.dt = {
                    // dns: "",
                    query: span.context.db.statement
                }
            } else if (span.context && span.context.http) {
                traceEntry.dt = {
                    url: span.context.http.url
                }
            }
            trace.entries.push(traceEntry)
            trace.funcs.push(span.name)
        });

        // let idFinderObject = {}
        // let multiDimensionArray = []
        // trace.entries.forEach((span, index) => {
        //     let indexToPush = idFinderObject[span.parent_id]
        //     if (span.level === 1) {
        //         multiDimensionArray.push( [ span ] )
        //         idFinderObject[span.parent_id] = span.parent_id
        //     } else {

        //     }
        // }

        // let transaction_id = event.transaction_id
        // for (let i = event.spansArray.length - 1; i >= 0; i--) {
        //     if (event.spansArray[i].parent_id != transaction_id && event.spansArray[i + 1]) {
        //         event.spansArray[i].lv = event.spansArray[i + 1].lv + 1
        //     }
        // }

        tracesPayload.push(trace)
    });

    return {
        startTime: new Date().getTime() - (60*1000),
        endTime: new Date().getTime(),
        traces: tracesPayload
    }
}

Aggregator.prototype.getAndResetTransactionsPayload = function () {

    let transactions = this.transactions
    this.resetTransactions()

    let txnsPayload = []
    for (let txnName of Object.keys(transactions)) {

        let txn = transactions[txnName]
        txn.traces = Object.values(txn.spansObject)

        delete txn.spansObject
        txnsPayload.push(txn)
    }

    return {
        startTime: new Date().getTime() - (60*1000),
        endTime: new Date().getTime(),
        transactions: txnsPayload
    }
}

Aggregator.prototype.getAndResetErrorEventsPayload = function () {
    let errorEvents = this.errorEvents.toArray()

    this.resetErrorEvents()

    return {
        errors: errorEvents
    }
}

Aggregator.prototype.getAndResetErrorMetricsPayload = function () {

    let errorMetrics = Object.values(this.errorMetrics)
    let errorRequests = this.errorRequests.toArray()

    this.resetErrorMetrics()

    return {
        startTime: new Date().getTime() - (60*1000),
        endTime: new Date().getTime(),
        errorMetrics: errorMetrics,
        errorRequests: errorRequests
    }
}

Aggregator.prototype.getAndResetMetrics = function () {

    let metrics = this.metrics
    this.resetMetrics()
    return {
        startTime: new Date().getTime() - (60*1000),
        endTime: new Date().getTime(),
        metrics: {
            nodejs: metrics,
        }
    }
}

Aggregator.prototype.getAndResetHostInfoPayload = function () {
    return {
    }
}

Aggregator.prototype.resetTransactions = function () {
    this.transactions = {}
}

Aggregator.prototype.resetTraces = function () {
    this.traceEvents = new LimitedPriorityQueue(TRACE_EVENTS_LIMIT)
}

Aggregator.prototype.resetErrorEvents = function () {
    this.errorEvents = new Queue(ERROR_EVENTS_LIMIT)
}

Aggregator.prototype.resetErrorMetrics = function () {
    this.errorMetrics = {}
    this.errorRequests = new Queue(ERROR_REQUESTS_LIMIT)
}

Aggregator.prototype.resetMetrics = function () {
    this.metrics = []
}

Aggregator.prototype.mergeTransactions = function(payload) {

}
Aggregator.prototype.mergeTraces = function(payload) {

}
Aggregator.prototype.mergeErrorEventsPayload = function(payload) {

}
Aggregator.prototype.mergeErrorMetrics = function(payload) {

}
Aggregator.prototype.mergeMetrics = function(payload) {

}


Aggregator.prototype.isTransactionsEmpty = function () {
    return (Object.keys(this.transactions).length < 1)
}

Aggregator.prototype.isTracesEmpty = function () {
    return (this.traceEvents.length < 1)
}

Aggregator.prototype.isErrorEventsEmpty = function () {
    return (this.errorEvents.length < 1)
}

Aggregator.prototype.isErrorMetricsEmpty = function () {
    return (this.errorRequests.length < 1)
}
Aggregator.prototype.isMetricsEmpty = function () {
    return (this.metrics.length < 1)
}
